/// <reference types="node" />
import { MaybeTimeDuration } from 'typed-duration';
import * as ZB from '../lib/interfaces-1.0';
import * as Grpc from '../lib/interfaces-grpc-1.0';
import { Loglevel, ZBClientOptions } from '../lib/interfaces-published-contract';
import { TypedEmitter } from '../lib/TypedEmitter';
import { ZBBatchWorker } from './ZBBatchWorker';
import { ZBWorker } from './ZBWorker';
export declare const ConnectionStatusEvent: {
    close: "close";
    connectionError: "connectionError";
    ready: "ready";
    unknown: "unknown";
};
export declare class ZBClient extends TypedEmitter<typeof ConnectionStatusEvent> {
    static readonly DEFAULT_CONNECTION_TOLERANCE: import("typed-duration").Milliseconds;
    private static readonly DEFAULT_MAX_RETRIES;
    private static readonly DEFAULT_MAX_RETRY_TIMEOUT;
    private static readonly DEFAULT_LONGPOLL_PERIOD;
    private static readonly DEFAULT_POLL_INTERVAL;
    connectionTolerance: MaybeTimeDuration;
    connected?: boolean;
    readied: boolean;
    gatewayAddress: string;
    loglevel: Loglevel;
    onReady?: () => void;
    onConnectionError?: () => void;
    private logger;
    private closePromise?;
    private closing;
    private grpc;
    private options;
    private workerCount;
    private workers;
    private retry;
    private maxRetries;
    private maxRetryTimeout;
    private oAuth?;
    private basicAuth?;
    private useTLS;
    private stdout;
    private customSSL?;
    /**
     *
     * @param options Zero-conf constructor. The entire ZBClient connection config can be passed in via the environment.
     */
    constructor(options?: ZBClientOptions);
    constructor(gatewayAddress: string, options?: ZBClientOptions);
    activateJobs<Variables = ZB.IInputVariables, CustomHeaders = ZB.ICustomHeaders>(request: Grpc.ActivateJobsRequest): Promise<ZB.Job[]>;
    cancelProcessInstance(processInstanceKey: string | number): Promise<void>;
    createBatchWorker<WorkerInputVariables = ZB.IInputVariables, CustomHeaderShape = ZB.ICustomHeaders, WorkerOutputVariables = ZB.IOutputVariables>(conf: ZB.ZBBatchWorkerConfig<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>): ZBBatchWorker<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>;
    createWorker<WorkerInputVariables = ZB.IInputVariables, CustomHeaderShape = ZB.ICustomHeaders, WorkerOutputVariables = ZB.IOutputVariables>(config: ZB.ZBWorkerConfig<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>): ZBWorker<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>;
    /**
     * Gracefully shut down all workers, draining existing tasks, and return when it is safe to exit.
     * @returns Promise
     * @memberof ZBClient
     */
    close(timeout?: number): Promise<null>;
    completeJob(completeJobRequest: Grpc.CompleteJobRequest): Promise<void>;
    createProcessInstance<Variables = ZB.IProcessVariables>(bpmnProcessId: string, variables: Variables): Promise<Grpc.CreateProcessInstanceResponse>;
    createProcessInstance<Variables = ZB.IProcessVariables>(config: {
        bpmnProcessId: string;
        variables: Variables;
        version: number;
    }): Promise<Grpc.CreateProcessInstanceResponse>;
    createProcessInstanceWithResult<Variables = ZB.IInputVariables, Result = ZB.IOutputVariables>(bpmnProcessId: string, variables: Variables): Promise<Grpc.CreateProcessInstanceWithResultResponse<Result>>;
    createProcessInstanceWithResult<Variables = ZB.IProcessVariables, Result = ZB.IOutputVariables>(config: ZB.CreateProcessInstanceWithResult<Variables>): Promise<Grpc.CreateProcessInstanceWithResultResponse<Result>>;
    createProcessInstanceWithResult<Variables = ZB.IProcessVariables, Result = ZB.IOutputVariables>(bpmnProcessId: string, variables: Variables): Promise<Grpc.CreateProcessInstanceWithResultResponse<Result>>;
    deployResource(resource: {
        processFilename: string;
    } | {
        name: string;
        process: Buffer;
    }): Promise<Grpc.DeployResourceResponse<Grpc.ProcessDeployment>>;
    deployResource(resource: {
        decisionFilename: string;
    } | {
        name: string;
        decision: Buffer;
    }): Promise<Grpc.DeployResourceResponse<Grpc.DecisionDeployment>>;
    deployProcess(process: ZB.DeployProcessFiles | ZB.DeployProcessBuffer): Promise<Grpc.DeployProcessResponse>;
    failJob(failJobRequest: Grpc.FailJobRequest): Promise<void>;
    /**
     * Return an array of task-types specified in a BPMN file.
     * @param file - Path to bpmn file.
     */
    getServiceTypesFromBpmn(files: string | string[]): Promise<string[]>;
    /**
     * Publish a message to the broker for correlation with a workflow instance.
     * @param publishMessageRequest - The message to publish.
     */
    publishMessage<ProcessVariables extends {
        [key: string]: any;
    } = ZB.IProcessVariables>(publishMessageRequest: Grpc.PublishMessageRequest<ProcessVariables>): Promise<Grpc.PublishMessageResponse>;
    /**
     * Publish a message to the broker for correlation with a workflow message start event.
     * @param publishStartMessageRequest - The message to publish.
     */
    publishStartMessage<ProcessVariables extends ZB.IInputVariables = ZB.IProcessVariables>(publishStartMessageRequest: Grpc.PublishStartMessageRequest<ProcessVariables>): Promise<Grpc.PublishMessageResponse>;
    resolveIncident(resolveIncidentRequest: Grpc.ResolveIncidentRequest): Promise<void>;
    setVariables<Variables = ZB.IProcessVariables>(request: Grpc.SetVariablesRequest<Variables>): Promise<void>;
    /**
     *
     * Report a business error (i.e. non-technical) that occurs while processing a job.
     * The error is handled in the workflow by an error catch event.
     * If there is no error catch event with the specified errorCode then an incident will be raised instead.
     */
    throwError(throwErrorRequest: Grpc.ThrowErrorRequest): Promise<void>;
    /**
     * Return the broker cluster topology
     */
    topology(): Promise<Grpc.TopologyResponse>;
    updateJobRetries(updateJobRetriesRequest: Grpc.UpdateJobRetriesRequest): Promise<void>;
    private constructGrpcClient;
    /**
     * If this.retry is set true, the operation will be wrapped in an configurable retry on exceptions
     * of gRPC error code 14 - Transient Network Failure.
     * See: https://github.com/grpc/grpc/blob/master/doc/statuscodes.md
     * If this.retry is false, it will be executed with no retry, and the application should handle the exception.
     * @param operation A gRPC command operation
     */
    private executeOperation;
    private _onConnectionError;
    /**
     * This function takes a gRPC operation that returns a Promise as a function, and invokes it.
     * If the operation throws gRPC error 14, this function will continue to try it until it succeeds
     * or retries are exhausted.
     * @param operation A gRPC command operation that may fail if the broker is not available
     */
    private retryOnFailure;
}
